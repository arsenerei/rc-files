" XDG Configuration ---------------------------------------------------------{{{
" Following the XDG Base Directory Specification (thanks tlvince!)
" Has to come before plugin logic or else it won't work
set noswapfile
set directory=$XDG_CACHE_HOME/vim,~/,/tmp
set backupdir=$XDG_CACHE_HOME/vim,~/,/tmp
set backupskip=/tmp/*,/private/tmp/*  " stupid crontab
set runtimepath=$XDG_CONFIG_HOME/vim,$VIM,$VIMRUNTIME,$XDG_CONFIG_HOME/vim/after
set rtp+=/usr/local/Cellar/fzf/0.10.0 " trial for fzfness
let $MYVIMRC="$XDG_CONFIG_HOME/vim/vimrc"
let g:netrw_home=$XDG_CACHE_HOME . '/vim'

" }}}
" Plugins           ---------------------------------------------------------{{{

call plug#begin()

" Basic
Plug 'wincent/Command-T', {'do': 'cd ruby/command-t && ruby extconf.rb && make'}
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-commentary'
" Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-fugitive'
Plug 'tommcdo/vim-exchange'
Plug 'sjl/gundo.vim'
Plug 'vim-scripts/Align', {'on': 'Align'}
Plug 'othree/html5.vim'
Plug 'jceb/vim-orgmode'
Plug 'tpope/vim-capslock'

" Colorschemes
Plug 'junegunn/seoul256.vim'

" Clojure
Plug 'tpope/vim-fireplace', {'for': 'clojure'}
Plug 'guns/vim-clojure-static', {'for': 'clojure'}
Plug 'guns/vim-clojure-highlight', {'for': 'clojure'}
Plug 'tpope/vim-classpath', {'for': 'clojure'}
Plug 'guns/vim-sexp', {'for': 'clojure'}
Plug 'tpope/vim-sexp-mappings-for-regular-people', {'for': 'clojure'}

" Trials
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'mileszs/ack.vim'
Plug 'stefandtw/quickfix-reflector.vim'

Plug 'vim-scripts/ReplaceWithRegister'
Plug 'ehamberg/vim-cute-python'
Plug 'honza/vim-clojure-conceal'
Plug 'wellle/targets.vim'
Plug 'vim-scripts/diffchar.vim'
Plug 'arsenerei/vim-easymotion'

call plug#end()

syntax enable
filetype on
filetype plugin on
filetype indent on

" }}}
" Basic options     ---------------------------------------------------------{{{

set nocompatible
set viminfo+=n$XDG_CACHE_HOME/vim/viminfo " has to be after nocompatible
set backspace=indent,eol,start
set incsearch
set showcmd
set hidden
set ignorecase
set smartcase
set autoindent
set tabstop=4
set softtabstop=4
set expandtab
set shiftwidth=4
set shiftround
set wrap
set linebreak
set showbreak=+
set textwidth=80
set scrolloff=5
set laststatus=2
set ttimeoutlen=0 " no more pause on ESC
set list
set listchars=tab:▸\ ,extends:❯,precedes:❮,trail:·
set clipboard=unnamed
set foldlevelstart=0
set foldmethod=marker
set display=lastline

" trial
set lazyredraw

" term colors
if &t_Co > 255
    set t_Co=256
    colorscheme seoul256
else
    set t_Co=16
endif

if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif

" Auto format paragraphs
" A failed experiment.  There are too many edge cases where I don't want the
" paragraph autoformatted (e.g., writing code, paragraphs accidentally touching
" each other).  I would need to write a plugin to be smarter about when to
" format and when not to.
" augroup markdown
"     autocmd!
"     autocmd FileType markdown setl fo+=a
" augroup END

" Wildmenu completion {{{

set wildmenu
set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX stuff
set wildignore+=*.pyc                            " python bytecode

" }}}

" }}}
" Mappings          ---------------------------------------------------------{{{

let mapleader=','
let maplocalleader='\'

noremap Y y$

nnoremap <silent> <Space> :nohlsearch<CR><C-L>

" easier vim editing
nnoremap <silent> <Leader>ev :e $MYVIMRC<CR>
nnoremap <silent> <Leader>sv :source $MYVIMRC<CR>

nnoremap q; q:

" quicker window navigation
nnoremap <silent> <C-j> <C-w>j
nnoremap <silent> <C-k> <C-w>k
nnoremap <silent> <C-h> <C-w>h
nnoremap <silent> <C-l> <C-w>l

" get the commandline quickly
noremap ; :
noremap : ;

" Command-line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" gc is slower and harder to type
xmap <leader>c  <Plug>Commentary
nmap <leader>c  <Plug>Commentary
omap <leader>c  <Plug>Commentary
nmap <leader>cc <Plug>CommentaryLine

augroup MySyntax
    autocmd!
    autocmd BufRead,BufNewFile *.edn.*,*.pxi setfiletype clojure
    autocmd FileType vim setlocal keywordprg=:help
augroup END

" FIXME: work in progress to visual differentiate long lines. I'm aiming for a
" visually quieter editor. (e.g., set nonumber noruler)
" augroup MyError
"     autocmd!
"     highlight OverLength term=reverse ctermbg=236 guibg=#3F3F3F
"     " combine with execute and &textwidth to determine OverLength position
"     autocmd BufWinEnter * let w:m1=matchadd('OverLength', '\%80v.', +1)
" augroup END

" }}}
" Plugin options    ---------------------------------------------------------{{{

let g:EasyMotion_display_jump_message = 0
let g:pandoc_use_hard_wraps=1

" Not sure if I want to keep this, the default is 100, but I wrote something
" that was nearly double that.
let g:clojure_maxlines = 200

" Goyo
function! s:goyo_enter()
    let b:quitting = 0
    autocmd QuitPre <buffer> let b:quitting = 1
    Limelight
endfunction

function! s:goyo_leave()
    Limelight!
    " Quit Vim if this is the only remaining buffer
    if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
        qa
    endif
endfunction

let g:goyo_callbacks = [function('s:goyo_enter'), function('s:goyo_leave')]

let g:CommandTMatchWindowReverse=1

function! Quasi()
    if (!exists('*fireplace#ns'))
        echom "Fireplace is not working in this buffer!"
        return
    endif
    let ns = fireplace#ns()
    vnew "Quasi"
    setfiletype clojure
    set buftype=nofile
    call setbufvar("%", "fireplace_ns", ns)
endfunction

command! Q call Quasi()

nnoremap <silent> <Leader>t :FZF<CR>

function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

nnoremap <silent> <Leader>b :call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\   'down':    len(<sid>buflist()) + 2
\ })<CR>

cnoremap <silent> <c-l> <c-\>eGetCompletions()<cr>
"add an extra <cr> at the end of this line to automatically accept the fzf-selected completions.

function! Lister()
    call extend(g:FZF_Cmd_Completion_Pre_List,split(getcmdline(),'\(\\\zs\)\@<!\& '))
endfunction

function! CmdLineDirComplete(prefix, options, rawdir)
    let l:dirprefix = matchstr(a:rawdir,"^.*/")
    if isdirectory(expand(l:dirprefix))
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --select-1  --query=' .
                    \ a:rawdir[matchend(a:rawdir,"^.*/"):len(a:rawdir)], 
                    \'dir': expand(l:dirprefix)
                    \}), 
                    \'"' . escape(l:dirprefix, " ") . '" . escape(v:val, " ")'))
    else
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --query='. a:rawdir }),
                    \'escape(v:val, " ")')) 
        "dropped --select-1 to speed things up on a long query
endfunction

function! GetCompletions()
    let g:FZF_Cmd_Completion_Pre_List = []
    let l:cmdline_list = split(getcmdline(), '\(\\\zs\)\@<!\& ', 1)
    let l:Prefix = l:cmdline_list[0:-2]
    execute "silent normal! :" . getcmdline() . "\<c-a>\<c-\>eLister()\<cr>\<c-c>"
    let l:FZF_Cmd_Completion_List = g:FZF_Cmd_Completion_Pre_List[len(l:Prefix):-1]
    unlet g:FZF_Cmd_Completion_Pre_List
    if len(l:Prefix) > 0 && l:Prefix[0] =~
                \ '^ed\=i\=t\=$\|^spl\=i\=t\=$\|^tabed\=i\=t\=$\|^arged\=i\=t\=$\|^vsp\=l\=i\=t\=$'
                "single-argument file commands
        return CmdLineDirComplete(l:Prefix, "",l:cmdline_list[-1])
    elseif len(l:Prefix) > 0 && l:Prefix[0] =~ 
                \ '^arg\=s\=$\|^ne\=x\=t\=$\|^sne\=x\=t\=$\|^argad\=d\=$'  
                "multi-argument file commands
        return CmdLineDirComplete(l:Prefix, '--multi', l:cmdline_list[-1])
    else 
        return join(l:Prefix + fzf#run({
                    \'source':l:FZF_Cmd_Completion_List, 
                    \'options': '--select-1 --query='.shellescape(l:cmdline_list[-1])
                    \})) 
    endif
endfunction

" }}}
